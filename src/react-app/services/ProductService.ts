import { authService } from './AuthService';
import { CONFIG } from '../config';

export interface Product {
    id: string;
    name: string;
    brand: string;
    category: string;
    description: string;
    price: number;
    stock: number;
    minStock: number;
    unit: string;
    status: 'Active' | 'Inactive';
    serialNumber?: string;
    warranty?: string;
    model?: string;
    createdAt: string;
    updatedAt: string;
    branch?: string;
    createdBy?: string;
}

class ProductService {
    private API_URL = `${CONFIG.API_BASE_URL}/products`;

    async getAllProducts(): Promise<Product[]> {
        try {
            const response = await fetch(this.API_URL);
            if (!response.ok) throw new Error('Failed to fetch products');
            return await response.json();
        } catch (error) {
            console.error('Error fetching products:', error);
            return [];
        }
    }

    async getProductById(id: string): Promise<Product | undefined> {
        try {
            const response = await fetch(`${this.API_URL}/${id}`);
            if (!response.ok) return undefined;
            return await response.json();
        } catch (error) {
            console.error('Error fetching product:', error);
            return undefined;
        }
    }

    async addProduct(product: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product | null> {
        try {
            const user = authService.getCurrentUser();
            const newProduct = {
                ...product,
                // id: Generated by backend (VKPxxxx)
                branch: user?.branch || 'Main',
                createdBy: user?.username || 'System'
            };

            const response = await fetch(this.API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(newProduct)
            });

            if (!response.ok) throw new Error('Failed to create product');
            return await response.json();
        } catch (error) {
            console.error('Error adding product:', error);
            return null;
        }
    }

    async updateProduct(id: string, updates: Partial<Product>): Promise<Product | null> {
        try {
            const response = await fetch(`${this.API_URL}/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updates)
            });

            if (!response.ok) throw new Error('Failed to update product');
            return await response.json();
        } catch (error) {
            console.error('Error updating product:', error);
            return null;
        }
    }

    async deleteProduct(id: string): Promise<boolean> {
        try {
            const response = await fetch(`${this.API_URL}/${id}`, {
                method: 'DELETE'
            });
            return response.ok;
        } catch (error) {
            console.error('Error deleting product:', error);
            return false;
        }
    }

    async updateStock(id: string, quantitySold: number): Promise<boolean> {
        // This logic is tricky because we need atomic updates
        // For now, we'll fetch, check, and update. Ideally, backend has a specialized endpoint.
        try {
            const product = await this.getProductById(id);
            if (!product) return false;

            if (product.stock >= quantitySold) {
                const newStock = product.stock - quantitySold;
                // Use the specialized patch endpoint if we created one, or regular PUT
                // server/routes/productRoutes.js has PATCH /:id/stock
                const response = await fetch(`${this.API_URL}/${id}/stock`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stock: newStock })
                });
                return response.ok;
            }
            return false;
        } catch (error) {
            console.error('Error updating stock:', error);
            return false;
        }
    }
}

export const productService = new ProductService();
